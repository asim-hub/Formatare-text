Asimionesei Daniel 311 CD

ELABORAT:
   Programul incepe prin includerea bibliotecilor cu  fisierele hedar stdio.h(functiile standard de intrare/iesire precum printf),stdint.h(tipuri a căror dimensiune este exact specificată: 64 biti) si math.h(functii matematice).Nu vom declara tablouri cu int v[100], ci vom folosi un macro pentru dimensiune(#define NMAX 8).
   Functia int main () incepe prin declararea unor variabile de 64 de biti fara semn (unsigned long long) si a unor variabile de tip int, printre care un vector( T[NMAX]) pe care il voi folosi pentru memorarea celor 8 transformările care trebuie aplicate asupra piesei corespunzatoare.Fiindca folosesc operatii pe biti am declarat si niste masti (mask1,..,mask4,a etc). Harta va fi memorata in variabila H, numarul de piese in variabila M , iar fiecare piesa in variabila P.
    Primul  for este folosit pentru citirea celor M piese ( for(i = 1; i <= M; i++) ).In cadrul acestui for , pe langa piesa se mai citesc cele 8 transformari.Piesa o voi SHIFTA  la stanga cu 48 astfel incat sa ajunga pe ultimii 16 biti.Sunt setate mastile mask1, mask2,mask3,mask4 pe care le voi folosi la trasformarile piesei.Daca prin coborare , piesa mea s-ar suprapune cu harta/nu ar avea loc in harta jocul s-ar termina ( if((P << 8) & H){... return 0;} ).Daca piesa are loc in harta programul continua printr-un While (while(T[1] != 0)) pe care il folosesc pentru transformarile piesei.Aici piesa o voi apela siftata la stanga cu 8 pentru ca transformarile le voi face pe linia 8 a hartii (linia superioara).In urma acestui while , piesa va fi transformata confor regulilor:sa nu treaca peste o zona deja ocupata  iar daca nu se pot efectua toata trasformarea , piesa va ramane acolo unde ii este permis.Astfel , dupa prima transformare vom afisa harta  newH , care este obtinuta prin operatia OR dintre harta H si piesa P shiftata cu 8 la stanga.NewH va fi harta de afisat dupa prima transformare, in care piesa se afla pe prima linie.Afisarea se face cu ajutorul functiei afisare care are ca parametru un numar pe 64 de biti.Mai departe verific din nou daca piesa poate cobora in harta (if(P & msk) if(P & H) ).Daca nu pot cobora in harta pe linia 7, voi afisa din nou newH si jocul se incheie.Fiindca piesa mea era shiftata inca de la inceput la stanga cu 48 ,voi apela functia  transformare() care primeste ca parametrii: masti ,transformarea ,piesa si harta.Piesa este un parametru de tip pointer fiindca vreu ca modificarile efectuate asupra piesei sa se transmita si in functia main().Dupa apelarea functiei , harta de afisat va fi reactualizata si afisata cu ajutorul functiei afisare().
    Mai departe acest algoritm de trasformare a piesei si de coborare in harta va fi generalizat printr-un for (for(k = 2; k <= 7; k++) )  unde voi shifta piesa la treapta cu 8 (coborarea pe linia urmatoare) prin apelarea functiei cobor_piesa(). Dupa coborare daca piesa se blocheaza ( if(P&H) ), voi verifica daca se pot elimina linii prin doua while-uri( pentru prima linie :(((a << (l * 8)) & H) == (a << (l*8))) , pentru restul liniilor: while(l <= 7) if(((a << (l * 8)) & H) == (a << (l * 8))) ) si voi face afisarea dupa eliminare daca este cazul. In eliminarea liniilor voi folosi masca a=255 (0...011111111).Daca piesa nu se blocheaza voi apela functia transformare() si voi reactualiza newH si voi afisa newH.Daca piesa ajunge pe ultima linie ( if(k == 7) )voi verifica si atunci daca se pot elinima linii si voi incepe prin eliminarea liniilor de jos in sus.
    In cazul in care s-au coborat in harta toate piesele ( if (i==M) ) jocul de va termina si se va calcula scorul prin apelarea funtiei score() , care primeste ca parametrii harta finala si nr de linii eliminate.
    Scorul este calculat si afisat si atunci cand piese nu mai incap in harta si jocul trebuie inceiat.
    De fiecare data cand o piesa isi epuizeaza transformarile sau nu le mai poate face pe toate , harta H se va reactualiza.

PE SCURT:
Functii:
1. afisare() -afisez harta;
2. transformare() -efectuiez transformarile posibile asupra pieselor;
3. cobor_piesa() - shiftez piesa la dreapta cu 8 (piesa initial este siftata cu 48 la stanga);
4. score() -calculez scorul final
 In int main() citesc harta , numarul de piese pentru ca mai apoi sa citesc fiecare piesa in parte si transformarile corespunzatoare intr-un vector.Pentru fiecare piesa voi verifica daca pot sa o cobor pana pe linile 8 si 7 a hartii, daca da ,voi afisa hartile actualizate , daca nu fie se incheie jocul daca nu mai exista loc in harta, fie se trece la citirea urmatoarei piese si transformarile corespunzatoare.Daca piesa a ajuns pe linia 7, printr-un for am generalizat coborarea piesei in harta, unde apelez functiile de mai sus si verific daca se pot elimina linii reactualizat si afisand harta de fiecare data.Daca toate mutarile au fost efectuate jocul se incheie ("GAME OVER" , Score:..) sau daca piesa nu are loc in intregime in hart, jocul de asemenea se incheie.Aceste conditii fiind puse atat atunci cand piesa coboara pe liniile 7 si 8 cat si atunci cand coboara in harta dupa linia 7.
 Am ales sa folosesc pointeri pentru ca am dorit ca atunci cand apelez functiile transformarile realizate asupra pieselor, de acestea, sa nu se piearda.As mai fi putut sa declar variabile globale in loc sa folosesc pointeri , dar acest lucru nu este recomandat.
 In program m-am folosit t de shiftari si operatii pe biti(& si |) pentru indeplinirea conditiilor de coborare in harta.
